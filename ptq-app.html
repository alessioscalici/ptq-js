<!DOCTYPE html><html><head><title>ptq-js by alessioscalici</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="assets/css/prism.css"><link rel="stylesheet" href="assets/css/jquery.qtip.min.css"><link rel="stylesheet" href="assets/css/main.css"></head><body class="homepage"><div id="page-wrapper"><div id="header-wrapper"><header class="container"><div id="logo"><h1><img src="assets/images/logo.png"><a href="index.html">Ptq</a></h1><span>the Ptq scanner / parser generator</span></div><nav id="nav"><ul><li><a href="https://github.com/alessioscalici/ptq-js/"><span class="icon fa-github"></span><span>GitHub Repo</span></a><a href="#overview-section">Overview</a><a href="#command-line-section">Command line</a><a href="#conflicts-section">Conflicts</a><a href="#scanners-section">Scanners</a><a href="#grammars-section">Grammars</a><a href="#templates-section">Templates</a></li></ul></nav></header></div><div id="banner-wrapper"><div id="banner" class="box container"><div id="overview-section" class="row"><div class="12u markdown"><h3>Overview</h3><a name="overview-section"></a><p>Ptq is a parsing system that helps programmers to quickly develop parsers and scanners.</p>

<p>It is designed to be:</p>

<ul><li><strong>Cross-platform</strong>: it&#39;s available as Windows installer and executable Jar file</li><li><strong>Cross-language</strong>: it saves parsers and scanners in files, no language-specific code is generated</li><li><strong>Easy to learn</strong>: it uses common regular expressions to describe parsers, and Backus-Naur Form for grammars</li><li><strong>Unicode compliant</strong>: the scanners can handle every Unicode character
Fast: it uses LALR(1) parsing algorithm by default</li></ul><h3>First steps</h3><a name="first-steps-section"></a><ul><li>Create a new project: click <code>File &gt; New project</code> and insert the name of your project. Ptq will create a sample parser recognizing simple mathematical expressions</li><li>Compile the project clicking <code>Project &gt; Compile</code></li><li>Open the project tree, then open the Test folder: there&#39;s a sample test file called <em>source.txt</em>. Open it (double click).</li></ul>

<p>If the last compilation was successful, when you open a test file the editor switches to the <strong>Test perspective</strong>.</p>

<p>In the Test perspective you can:</p>

<ul><li>Edit the text in the <strong>editor</strong> and save the file (File &gt; Save all or CTRL+S)</li><li>Double click on the text in the editor to see token informations in the <strong>Properties panel</strong></li><li>Click on a symbol name in the <strong>Terminal panel</strong> to highlight tokens in the editor</li><li>Click on a rule in the <strong>Rules panel</strong> to highlight rules in the editor</li></ul>

<p><strong>Only for parser projects:</strong></p>

<ul><li>Click on the &quot;play&quot; symbol in the top-right corner of the editor to see the parse tree in the <strong>Parse tree panel</strong>, or an error message in the Warning panel</li><li>If the text isn&#39;t recognized, an error message appears in the <strong>Warning panel</strong>. Click on the error message in the Warning panel to highlight the row in the editor</li><li>Click on a node in the <strong>Parse tree panel</strong> to highlight the corresponding text in the editor, and to see informations in the Properties panel (only for parser projects)</li></ul><h3>Command line</h3><a name="command-line-section"></a><h5>Start interactive mode</h5>

<p>Execute Ptq in interactive mode passing the option -i:</p>

<p><code>
path/to/ptq/ptq.jar -i
</code></p>

<h5>Exit interactive mode:</h5>

<p><code>
exit    # or &quot;quit&quot;
</code></p>

<h5>Create a new project in the current projects directory</h5>

<p><code>
create PROJECT_TYPE PROJECT_NAME
</code></p>

<ul><li>PROJECT_TYPE: <code>scanner</code> or <code>parser</code></li><li>PROJECT_NAME: The project name. It must contain only numbers, letters and underscores, and must begin with a letter or an underscore</li></ul>

<h5>Compile the project, generating the output scanner/parser file</h5>

<p><code>
compile PROJECT_NAME
</code></p>

<ul><li>PROJECT_NAME: A project name. The project must exists under the current Projects directory</li></ul>

<h5>Get the output in hexadecimal string format</h5>

<p><code>
hex PROJECT_NAME
</code></p>

<ul><li>PROJECT_NAME: A project name. The project must exists under the current Projects directory and must be successfully compiled first</li></ul>

<h5>Set the application language</h5>

<p><code>
set language LANGUAGE    # or &quot;set lang LANGUAGE&quot;
</code></p>

<ul><li>LANGUAGE: the application language to set, possible values are <code>it</code> (Italian), <code>en</code> (English)</li></ul>

<h5>Set the projects directory</h5>

<p><code>
set root PATH
</code></p>

<ul><li>PATH: the path to the new projects directory</li></ul>

<h5>Print informations</h5>

<p>Use the <code>echo</code> (alias: <code>print</code>) command to print informations:</p>

<ul><li><code>echo language</code> (or <code>print lang</code>): get the current application language</li><li><code>echo root</code>: get the current path of the projects directory</li><li><code>echo project-list</code>: get the list of project names in the current projects directory</li><li><code>echo charset-list</code>: get the list of available charset (the result is platform dependent)</li><li><code>echo version</code>: get the application version number</li></ul><h3>Conflicts</h3><a name="conflicts-section"></a><h4>Shift/Reduce conflicts (S/R)</h4>

<p>When a grammar allows a rule to be reduced for a certain token, but allows another rule to be shifted, there&#39;s a Shift/Reduce conflict. When that token is recognized, the parsing algorithm cannot decide between shifting a rule or reducing the other.
Here is an example:</p><pre><code class="ptqsh ptqsh-bnf">< if_statement > ::= if < condition > then < statement_list >

< if_statement > ::= if < condition > then < statement_list > else < statement_list >
</code></pre><p>The above rules describe a common if-then-else statement. This grammar is ambiguous, because when the &quot;else&quot; terminal is recognized, the parser can take two actions:</p>

<ol><li>Reduce the first rule</li><li>Shift the second rule</li></ol>

<p>Possible solutions are:</p>

<ul><li>Using the &quot;Shift on S/R conflicts&quot; option (always selected by default). When a S/R conflict occurs, the parser generator will always choose to shift. This is a very common behaviour for LR1 parser generators</li><li>Modifying the language: in the above example, you can add an &quot;end if&quot; token to terminate the if-then-else statement:</li></ul><pre><code class="ptqsh ptqsh-bnf">< if_statement > ::= if < condition > then < statement_list > end_if

< if_statement > ::= if < condition > then < statement_list > else < statement_list > end_if

</code></pre><h4>Reduce/Reduce conflicts (R/R)</h4>

<p>A Reduce/Reduce conflict occurs if there are two or more rules that apply to the same sequence of input, so the grammar allows more than one rule to be reduced for a certain token. When that token is recognized, the parsing algorithm cannot decide which of the two rules has to be reduced.</p>

<p>Usually a R/R conflict indicates a serious problem in the grammar. Usually you can resolve such kind of conflict modifying the grammar.</p>

<h4>LALR(1) conflicts</h4>

<p>Because of the way LALR(1) action-goto tables are built, some LR(1) grammars cannot be parsed using LALR(1) algorithm. If you try to generate LALR(1) tables for these grammars, you&#39;ll get a R/R conflict.</p>

<p>If this is the case, the easiest solution is to use the canonical LR1 algorithm or its reduced variant.</p><h3>Scanners</h3><a name="scanners-section"></a><p>The scanner is the module that performs lexical analisys.
It takes in input a sequence of characters, and returns a sequence of tokens.</p>

<p>Consider the following Javascript statement:</p>

<p><code>var iNumber = 6;</code></p>

<p>The lexical analisys would return the following tokens (ignoring whitespace):</p>

<ol><li><code>var</code>: the var keyword</li><li><code>iNumber</code>: the variable identifier</li><li><code>=</code>: the assignment operator</li><li><code>6</code>: an integer literal</li><li><code>;</code>: semicolumn</li></ol>

<p>Here is a scanner for the example above, declared using Ptq scanner language:</p><pre><code class="ptqsh ptqsh-scanner">--------------------------------------------------------------------------
myScanner

  whitespace   / [:space:] + / -ignore

  var_keyword  / var /
  identifier   / [a-zA-Z_] [a-zA-Z_0-9]* /
  equals_op    / = /
  integer      / [0-9] + /
  semicolon    / ; /
</code></pre><p>Every subscanner begins with two or more Hyphen (-) characters followed by an identifier (the subscanner name), and optionally some subscanner property.</p>

<p>The subscanner definition contains the patterns to be recognized (terminals). Every terminal is declared specifying a name and a pattern, and optionally some terminal property (in the above example, the &quot;whitespace&quot; terminal has the property <strong>-ignore</strong>, that causes the token to be skipped when recognized).</p>

<h4>Switching between subscanners</h4>

<p>The  <code>-goto foo</code> property means &quot;when this pattern is matched, start using the foo scanner&quot;.
Here is an example: the following scanner recognizes the common C comment block (  /*  ...  */  )</p><pre><code class="ptqsh ptqsh-scanner">-------------------------------------------------------
main

    text            / \* | \/ | [ [:ascii:] -[ /* ]] * /
    comment_start   / \/ \* /     -goto comment_block  -ignore

-------------------------------------------------------
comment_block

    comment_body    / \* | \/ | [ [:ascii:] -[ /* ]] * /  -ignore
    comment_end     / \* \/ /     -goto main -ignore

</code></pre><p>After the <code>comment_start</code> terminal is matched, <code>comment_block</code> becomes the current subscanner.
When <code>comment_end</code> is matched, <code>main</code> becomes the current subscanner.</p>

<p>Here is a sample input text:</p>

<p><code>
if (a &gt; b) {
  /* in this comment, nesting is not supported */
  a = 0;
}
</code></p>

<p>Here&#39;s what happens:</p>

<ol><li>At input start, the first subscanner (main) is executed.</li><li>After the first <strong>/*</strong> ( <code>{main.comment_start}</code> ), comment_block becomes the current subscanner.</li><li>After the first <strong>*/</strong>  ( <code>{comment_block.comment_end}</code> ) main becomes the current subscanner.</li></ol>

<h4>Nested blocks</h4>

<p>Nested blocks can be implemented using the <code>-start</code>  and <code>-stop</code> properties to switch between subscanners.</p>

<p>Here is an example: the following scanner recognizes a nested comment block</p><pre><code class="ptqsh ptqsh-scanner">-------------------------------------------------------
main

  text          / \* | \/ | [[:ascii:]-[/*]] * /
  comment_start / \/ \* /     -start comment_block -ignore

-------------------------------------------------------
comment_block

  comment_body  / \* | \/ | [[:ascii:]-[/*]] * / -ignore
  comment_start / \/ \* /      -start comment_block -ignore
  comment_stop  / \* \/ /      -stop -ignore
</code></pre><ul><li>The <strong>-start</strong> property means &quot;when the scanner matches this pattern, start using the comment_block subscanner&quot;</li><li>The <strong>-stop</strong> property means &quot;when this pattern is matched, restore the previous subscanner&quot;</li></ul>

<p>Here is a sample input text:</p>

<p><img alt="Nested blocks example" title="Nested blocks example" src="/assets/images/nested_blocks1.png"/></p>

<ol><li>At input start, the first subscanner (main) is executed.</li><li>After the first /* ( <strong>{ main.comment_start }</strong>), an instance of the comment_block subscanner starts.</li><li>After the second /* ( <strong>{ comment_block.comment_start }</strong> ), another instance of the comment_block subscanner starts.</li><li>After the first */  ( <strong>{ comment_block.comment_stop }</strong> ) the previous subscanner (the first instance of comment_block) is restored.</li><li>After the second */  ( <strong>{ comment_block.comment_stop }</strong> ) the previous subscanner (the main subscanner) is restored.</li></ol>

<h4>Pushback</h4>

<p>The <strong>-pushback</strong> property is always combined with <strong>-start</strong> or <strong>-goto</strong>. It means &quot;when this pattern is matched, push back the token characters to the input text&quot;. In other words, the incoming subscanner will read those characters, even if they were already scanned.</p>

<p>The following scanner recognizes a free ascii text. When a  &lt;  is found, it ignores it (<strong>-ignore</strong> property) and gives the &lt; character to the incoming subscanner (<strong>-goto tag_sub</strong>), that recognizes a sequence of XML-like tags.</p><pre><code class="ptqsh ptqsh-scanner">-------------------------------------------------------
main_sub

    free_text / [[:ascii:]-[<]] /
    tag_start / < / -goto tag_sub -pushback -ignore

-------------------------------------------------------
tag_sub

    tag / < [a-z] + > /
    tag_with_ns / < [a-z]+ : [a-z]+ > /


</code></pre><p>A sample input (the bold part is recognized by the <strong>tag_sub</strong> subscanner):</p>

<blockquote><p>This is free ascii text  <strong>&lt;sequence&gt;&lt;of&gt;&lt;xml:like&gt;&lt;tags&gt;</strong></p></blockquote>

<p>The first <code>&lt;</code> character is recognized as <strong>{ main_sub.tag_start }</strong>, it is pushed back to the input stream (<strong>-pushback</strong> property)
and recognized again as the first character of <strong>{ tag_sub.tag }</strong></p><h3>Character sets</h3><a name="character-sets-section"></a><p>When you have to match only one character out of several characters, you need to define a character set. To define a character set, put the characters you want to match into square brackets:</p>

<blockquote><p><strong>[AB]</strong> <em>matches</em> <code>A</code> or <code>B</code></p></blockquote>

<h4>Metacharacters</h4>

<p>The usual metacharacters are normal characters inside a character set, so they don&#39;t need to be escaped. The only metacharacters in character sets are:</p>

<ul><li><code>[</code> <em>left square bracket</em> (begin of the character set)</li><li><code>]</code> <em>right square bracket</em> (end of the character set)</li><li><code>-</code> <em>hyphen</em> (range operator)</li></ul>

<blockquote><p><strong>[A-D]</strong> <em>matches</em> <code>A</code> , <code>B</code> , <code>C</code> or <code>D</code> because the <code>-</code> (range operator) is not escaped</p><p><strong>[A-D]</strong> <em>matches</em> <code>A</code> , <code>-</code> or <code>D</code> because the <code>-</code> is escaped</p><p><strong>[[]]</strong> <em>matches</em> <code>[</code> or <code>]</code> because the brackets characters (into the character set) are escaped</p></blockquote>

<h4>Whitespaces</h4>

<p>In a character set, whitespaces are considered as normal characters:</p>

<blockquote><p><strong>[ ]</strong> <em>matches</em> <code> </code> (whitespace)</p><p><strong>[A B]</strong> <em>matches</em> <code>A</code>, <code>B</code> or <code> </code> (whitespace)</p></blockquote>

<h4>Ranges</h4>

<p>An hyphen <code>-</code> between two characters defines a range of characters:</p>

<blockquote><p><strong>[A-D]</strong> <em>matches</em> <code>A</code> , <code>B</code> , <code>C</code> or <code>D</code></p><p><strong>[0-9]</strong> <em>matches</em> all digits from <code>0</code> to <code>9</code></p><p><strong>[A-\u45]</strong> <em>matches</em> all uppercase letters from <code>A</code> to <code>E</code> (U+0045)</p><p><strong>[0-9]</strong> <em>matches</em> <code>0</code> or <code>9</code> (the <code>-</code> is escaped)</p></blockquote>

<h4>Pre-defined character sets</h4>

<h5>POSIX character classes</h5>

<blockquote><p><code>[:alnum:]</code> <em>matches</em> all alphanumeric characters (equiv. <code>[a-zA-Z0-9]</code>)</p><p><code>[:alpha:]</code> <em>matches</em> all letters (equiv. <code>[a-zA-Z]</code>)</p><p><code>[:ascii:]</code> <em>matches</em> all ASCII characters (equiv. <code>[\u00-\u7F]</code>)</p><p><code>[:blank:]</code> <em>matches</em> Space and tab (equiv. <code>[ \t]</code>)</p><p><code>[:cntrl:]</code> <em>matches</em> all Control characters (equiv. <code>[\u00-\u1F\u7F]</code>)</p><p><code>[:digit:]</code> (<code>\d</code>) <em>matches</em> all Digits (equiv. <code>[0-9]</code>)</p><p><code>[:graph:]</code> <em>matches</em> all ASCII characters (equiv. <code>[\u00-\u7F]</code>)</p><p><code>[:lower:]</code> <em>matches</em> all Lowercase letters (equiv. <code>[a-z]</code>)</p><p><code>[:print:]</code> <em>matches</em> all Visible characters and spaces (anything but control characters) (equiv. <code>[\u20-\u7E]</code>)</p><p><code>[:punct:]</code> <em>matches</em> all Punctuation and symbols (equiv. <code>[!&quot;#$%&amp;&#39;()*+,\-./:;&lt;=&gt;?@\[\\\]^_`{|}~]</code>)</p><p><code>[:space:]</code> (<code>\s</code>) <em>matches</em> all whitespace characters, including line breaks (equiv. <code>[ \t\r\n\v\f]</code>)</p><p><code>[:upper:]</code> <em>matches</em> all Uppercase letters (equiv. <code>[A-Z]</code>)</p><p><code>[:word:]</code> (<code>\w</code>) <em>matches</em> all Word characters (letters, numbers and underscores) (equiv. <code>[a-zA-Z0-9_]</code>)</p><p><code>[:xdigit:]</code> <em>matches</em> all Hexadecimal digits (equiv. <code>[a-fA-F0-9]</code>)</p></blockquote>

<h5>Unicode Scripts</h5>

<p>You can refer to <a href="http://en.wikipedia.org/wiki/Script_(Unicode)">Unicode Scripts</a> using their name, with the following syntax:</p>

<p><strong>\p{</strong>SCRIPT_NAME<strong>}</strong></p>

<p>For example:</p>

<blockquote><p><code>\p{Latin}</code> <em>matches</em> all the characters in the &quot;Latin&quot; Unicode Script</p></blockquote>

<h5>Unicode Blocks</h5>

<p>You can refer to <a href="http://en.wikipedia.org/wiki/Unicode_block">Unicode Blocks</a> using their name, with the following syntax:</p>

<p><strong>\p{In</strong>SCRIPT_NAME<strong>}</strong></p>

<p>For example:</p>

<blockquote><p><code>\p{InCyrillic}</code> <em>matches</em> all the characters in the &quot;Cyrillic&quot; Unicode Block</p></blockquote>

<h5>Unicode Categories</h5>

<p>You can match characters that are part of a Unicode Category using the category name, with the following syntax:</p>

<p><strong>\p{Is</strong>CATEGORY_NAME<strong>}</strong></p>

<p>For example:</p>

<blockquote><p><code>\p{InUppercase}</code> <em>matches</em> all the characters in the &quot;Uppercase&quot; Unicode Category</p></blockquote>

<h4>Custom character classes</h4>

<p>If you use the same character set more than one time, you can define it once and reference it multiple times with his name:</p><pre><code class="ptqsh ptqsh-scanner">// Define here your custom character sets
// Syntax:   NAME [ ...character set definition... ]

MyCharacterSet [#';]

-- myScanner
    MY_TERMINAL    / {MyCharacterSet} /     // <-- matches  "#", "'" or ";"
    MY_TERMINAL_2  / {MyCharacterSet} A  /  // <-- matches  "#A", "'A" or ";A"

</code></pre><p>then, you can refer to the character set in your patterns using the syntax <code>{CHARACTER_SET_NAME}</code></p><h3>Properties</h3><a name="properties-section"></a><p>Properties are settings applicable to the global scanner, the subscanners and the terminals to
modify the scanner behavior.</p>

<h4>Scanner properties</h4>

<p><code>-eos-symbol &lt;name&gt;</code> defines a custom name for the &quot;end of stream&quot; symbol (default: <em>EOS</em>)</p>

<p><code>-error-symbol &lt;name&gt;</code> defines a custom name for the &quot;error&quot; symbol (default: <em>ERROR</em>)</p>

<p><code>-begin-symbol &lt;name&gt;</code> defines a custom name for the &quot;begin block&quot; symbol (default: <em>BEGIN</em>)</p>

<p><code>-end-symbol &lt;name&gt;</code> defines a custom name for the &quot;end block&quot; symbol (default: <em>END</em>)</p>

<h4>Sub-scanner properties</h4>

<p><code>-fix-priority &lt;integer&gt;</code> The priority for every static-length terminal (e.g. keywords, operators, parentheses)</p>

<p><code>-var-priority &lt;integer&gt;</code> The priority for every variable-length terminal (e.g. identifiers, literal numbers, literal strings)</p>

<h4>Terminal properties</h4>

<p><code>-ignore</code> Ignore this token when matched</p>

<p><code>-goto &lt;subscanner name&gt;</code> Start using another subscanner after match</p>

<p><code>-start &lt;subscanner name&gt;</code> Start using another subscanner after match. When a terminal with the <strong>-stop</strong> option is matched, the previous subscanner is restored</p>

<p><code>-stop</code> Restores the previous subscanner after match</p>

<p><code>-pushback</code> When <strong>-start</strong> or <strong>-goto</strong> are triggered, the current token string is pushed back into the input stream, so that the starting subscanner can read it again</p>

<p><code>-priority &lt;integer&gt;</code> When two terminals can match the same word, you can give an higher (or lower) priority to one of them</p><pre><code class="ptqsh ptqsh-scanner">-- myScanner

    WORD    / [a-z]+ /
    FOR     / for  /

</code></pre><p>Here, the word &quot;for&quot; can be matched by both the terminals. Setting an higher priority to FOR will resolve the conflict, matching FOR only when the word &quot;for&quot; is matched, and WORD in every other case:</p><pre><code class="ptqsh ptqsh-scanner">-- myScanner

    WORD    / [a-z]+ /    -priority 5
    FOR     / for  /      -priority 3
</code></pre><p><code>-indent</code> In indentation-based scanners, use this property to indicate the &quot;indentation&quot; terminal, whose lenght determines the indentation level. This property is usually used together with the <strong>-ignore</strong> property. You should never put newline characters in an <strong>-indent</strong> terminal.</p><pre><code class="ptqsh ptqsh-scanner">-- myScanner

    INDENT     /  [ \t]+  /   -indent -ignore
    NEWLINE    /  \n   /



</code></pre><h3>Grammars</h3><a name="grammars-section"></a><p>Ptq uses <strong>BNF (Backus-Naur Form)</strong> to define grammars, a very common notation for grammar specifications. This format is easy to understand and quick to learn.
The BNF meta-symbols are:</p>

<blockquote><p><code>::=</code> <strong>is defined as</strong>: separates the rule&#39;s head from his handle</p><p><code>|</code> <strong>or</strong>: pipe indicates alternative handles</p><p><code>&lt; non_terminal_name &gt;</code> <strong>non terminal symbol</strong>: angle brackets surround Non-terminal symbol names</p><p><code>terminal_name</code> <strong>terminal symbol</strong>: any name not surrounded by angle brackets is a Terminal symbol</p></blockquote>

<p>A BNF specification is a set of derivation rules, written in the following form:</p>

<p><img alt="Rule example" title="Rule example" src="/assets/images/rule.png"/></p>

<p>Here is an example:</p><pre><code class="ptqsh ptqsh-bnf">< expression > ::= < expression_term >
< expression > ::= < expression > plus < expression_term >
< expression > ::= < expression > minus < expression_term >

< expression_term > ::= integer
< expression_term > ::= variable_name
</code></pre><p>The above grammar can be written using the pipe <code>|</code> choice operator:</p><pre><code class="ptqsh ptqsh-bnf">< expression > ::= < expression_term >
  |  < expression > plus < expression_term >
  |  < expression > minus < expression_term >

< expression_term > ::= integer | variable_name
</code></pre><h4>Terminal and Non-terminal symbols</h4>

<p>In BNF specification there are two kinds of symbols: <strong>Teminal</strong> and <strong>Non-terminal</strong> symbols.</p>

<p>Terminal symbols represent the text recognized and tokenized by the scanner. In a parse tree, terminals are always leaves, and each of them represents a token. They are referenced in the grammar specification using their name (the identifier used in the scanner specification).</p>

<p>Terminal symbols have to be defined in the scanner specification as non-ignored terminals (they must be defined at least in one subscanner without the -ignore property), using their identifier.</p>

<p>Non-terminal symbols represent the rules used to derive the input text. In a parse tree, they are represented by non-terminal nodes. They are referenced using an identifier surrounded by angle brackets.</p>

<p>Non-terminal symbols have to be defined as head symbol for at least one rule. They can be referenced using their identifier surrounded by angle brackets <code>&lt;&gt;</code>.</p><h3>Templates</h3><a name="templates-section"></a><p>Every symbol and every rule in the scanner/parser are identified by an index (32 bit integer).</p>

<p>Usually, a developer has to write a set of constants/enumeration to easily identify specific rules and symbols in the code, but this can be a really tedious task because:</p>

<ol><li>A scanner/parser can have dozens (or hundreds!) of rules/symbols</li><li>Indexes may vary if a scanner/parser is modified</li><li>It&#39;s boring</li></ol>

<p>To makes things easier, PTQ provides a template processing tool that allows automatic generation of this kind of code.
A template is a normal text file, coden in the targeted language, with some pre-processing tags. For example, the following template:</p><pre><code class="lang-template">public enum #project name#Symbols
{
    #foreach symbol#
    S_#name# = #index# %%,%%
    #end symbol#
}

</code></pre><p>Will result in a Java enum like the following:</p><pre><code class="lang-template">public enum MyProjectSymbols
{ 
    S__EOS_ = 0,
    S__ERROR_ = 1,
    S_MY_FIRST_SYMBOL = 2,
    S_MY_SECOND_SYMBOL = 3,
    S_MY_THIRD_SYMBOL = 4
}

</code></pre><h4>Tag list</h4>

<h5>Global</h5>

<p><code>#project name#</code> The project name</p>

<p><code>#terminal count#</code> The number of terminal symbols</p>

<p><code>#start symbol name#</code> The grammar start symbol name</p>

<p><code>#start symbol index#</code> The grammar start symbol index</p>

<p><code>#symbol count#</code> The total number of symbols ( terminal + non-terminal )</p>

<p><code>#rule count#</code> The number of  rules in the grammar</p>

<h5>List separator</h5>

<p><code>%%</code> In every list you can surround a list separator between <strong>%%</strong> (e.g.  <code>%%,%%</code>). The separator will be omitted after the last occurrence in the list.</p>

<h5>Terminal list</h5>

<p><code>#for each terminal#</code> Starts the terminal symbol list. The code between this tag and <strong>#end terminal#</strong> will be repeated for each terminal symbol</p>

<p><code>#name#</code> The terminal name (identifier)</p>

<p><code>#index#</code> The terminal index</p>

<p><code>#display name#</code> The terminal display name</p>

<p><code>#end terminal#</code> Terminates the terminal symbol list</p>

<h5>Symbol list</h5>

<p><code>#for each symbol#</code> Starts the symbol list. The code between this tag and <strong>#end symbol#</strong> will be repeated for each symbol (terminal + non-terminal)</p>

<p><code>#name#</code> The symbol name (identifier)</p>

<p><code>#index#</code> The symbol index</p>

<p><code>#end symbol#</code> Terminates the symbol list</p>

<h5>Rule list</h5>

<p><code>#for each rule#</code> Starts the rule list. The code between this tag and <strong>#end rule#</strong> will be repeated for each grammar rule</p>

<p><code>#rule#</code> The grammar rule in BNF format (e.g.  <code>&lt;expr&gt; ::= LPAR &lt;expr&gt; RPAR</code> )</p>

<p><code>#rule index#</code> The rule index</p>

<p><code>#rule identifier#</code> A unique rule identifier, built using symbols name (e.g. <code>expr_LPAR_expr_RPAR</code>), can be used to have an index-independent identifier for the rule</p>

<p><code>#rule md5#</code> The MD5 digest string of the rule, can be used to have an index-independent identifier for the rule</p>

<p><code>#head name#</code> The name of the head symbol (LHS)</p>

<p><code>#head index#</code> The index of the head symbol (LHS)</p>

<p><code>#element count#</code> The number of symbols in the rule&#39;s tail (RHS)</p>

<p><code>#for each element#</code> Starts the rule tail list. The code between this tag and <strong>#end element#</strong> will be repeated for each symbol in the rule tail (RHS)</p>

<p><code>#name#</code> The RHS symbol name</p>

<p><code>#index#</code> The RHS symbol index</p>

<p><code>#end element#</code> Terminates the rule tail list</p>

<p><code>#end rule#</code> Terminates the rule list</p>

<h5>Non-terminal list</h5>

<p><code>#for each nonterminal#</code> Starts the non-terminal symbol list. The code between this tag and <strong>#end nonterminal#</strong> will be repeated for each non-terminal symbol</p>

<p><code>#name#</code> The non-terminal symbol name (identifier)</p>

<p><code>#index#</code> The non-terminal symbol index</p>

<p><code>#for each rule#</code> Starts the rule list. The code between this tag and <strong>#end rule#</strong> will be repeated for each grammar rule with the current non-terminal symbol as his head (LHS)</p>

<p><em>... see rule tags ...</em></p>

<p><code>#end rule#</code> Terminates the rule list</p>

<p><code>#end nonterminal#</code> Terminates the non-terminal symbol list</p></div></div></div></div><div id="footer-wrapper"><footer id="footer" class="container"><div class="row"><div class="3u 6u(medium) 12u$(small)"><section class="widget contact"><h3>Author</h3><a href="http://alessioscalici.it" title="Website">Alessio Scalici</a><ul class="style2"><li><a href="https://alessioscalici.github.io" title="GitHub page" class="icon fa-github"><span class="label">GitHub page</span></a></li><li><a href="https://ie.linkedin.com/in/alessioscalici" title="LinkedIn profile" class="icon fa-linkedin"><span class="label">LinkedIn</span></a></li></ul></section></div><div class="3u 6u(medium) 12u$(small)"><section class="widget links"><h3>ptq-js</h3><ul class="style2"><li>Fast</li><li>Reliable</li><li>Easy to learn</li></ul></section></div><div class="3u 6u(medium) 12u$(small)"><section class="widget links"><h3>Applications</h3><ul class="style2"><li>Language analysis</li><li>Syntax highlighting</li><li>Complex validation</li></ul></section></div><div class="3u 6u(medium) 12u$(small)"><section class="widget links"><h3>Ptq resources</h3><ul class="style2"><li><a href="http://alessioscalici.it/ptq" title="Ptq">Homepage</a></li><li><a href="http://alessioscalici.it/ptq/reference.html" title="Ptq docs">Docs</a></li><li><a href="assets/apps/ptq.jar" title="Ptq download">Download Ptq 2.0.1</a></li></ul></section></div></div><div class="row"><div class="12u"><div id="copyright"><ul class="menu"><li>&copy; Alessio Scalici. All rights reserved</li></ul></div></div></div></footer></div></div><script src="assets/js/jquery.min.js"></script><script src="assets/js/jquery.dropotron.min.js"></script><script src="assets/js/skel.min.js"></script><script src="assets/js/util.js"></script><!--[if lte IE 8]><script src="assets/js/ie/respond.min.js"></script><![endif]--><script src="assets/js/main.js"></script><script src="assets/js/prism.js"></script><script src="assets/js/jquery.qtip.min.js"></script><script src="assets/js/ptq/ptq.js"></script><script src="assets/js/ptq-sh.js"></script></body></html>