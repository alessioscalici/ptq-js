<!DOCTYPE html><html><head><title>ptq-js by alessioscalici</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="assets/css/prism.css"><link rel="stylesheet" href="assets/css/jquery.qtip.min.css"><link rel="stylesheet" href="assets/css/main.css"></head><body class="homepage"><div id="page-wrapper"><div id="header-wrapper"><header class="container"><div id="logo"><h1><img src="assets/images/logo.png"><a href="index.html">Ptq</a></h1><span>the Ptq scanner / parser generator</span></div><nav id="nav"><ul><li><a href="https://github.com/alessioscalici/ptq-js/"><span class="icon fa-github"></span><span>GitHub Repo</span></a><a href="#overview-section">Overview</a></li></ul></nav></header></div><div id="banner-wrapper"><div id="banner" class="box container"><div id="overview-section" class="row"><div class="12u markdown"><h3>Overview</h3><a name="overview-section"></a><p>Ptq is a parsing system that helps programmers to quickly develop parsers and scanners.</p>

<p>It is designed to be:</p>

<ul><li><strong>Cross-platform</strong>: it&#39;s available as Windows installer and executable Jar file</li><li><strong>Cross-language</strong>: it saves parsers and scanners in files, no language-specific code is generated</li><li><strong>Easy to learn</strong>: it uses common regular expressions to describe parsers, and Backus-Naur Form for grammars</li><li><strong>Unicode compliant</strong>: the scanners can handle every Unicode character
Fast: it uses LALR(1) parsing algorithm by default</li></ul><h3>First steps</h3><a name="first-steps-section"></a><ul><li>Create a new project: click <code>File &gt; New project</code> and insert the name of your project. Ptq will create a sample parser recognizing simple mathematical expressions</li><li>Compile the project clicking <code>Project &gt; Compile</code></li><li>Open the project tree, then open the Test folder: there&#39;s a sample test file called <em>source.txt</em>. Open it (double click).</li></ul>

<p>If the last compilation was successful, when you open a test file the editor switches to the <strong>Test perspective</strong>.</p>

<p>In the Test perspective you can:</p>

<ul><li>Edit the text in the <strong>editor</strong> and save the file (File &gt; Save all or CTRL+S)</li><li>Double click on the text in the editor to see token informations in the <strong>Properties panel</strong></li><li>Click on a symbol name in the <strong>Terminal panel</strong> to highlight tokens in the editor</li><li>Click on a rule in the <strong>Rules panel</strong> to highlight rules in the editor</li></ul>

<p><strong>Only for parser projects:</strong></p>

<ul><li>Click on the &quot;play&quot; symbol in the top-right corner of the editor to see the parse tree in the <strong>Parse tree panel</strong>, or an error message in the Warning panel</li><li>If the text isn&#39;t recognized, an error message appears in the <strong>Warning panel</strong>. Click on the error message in the Warning panel to highlight the row in the editor</li><li>Click on a node in the <strong>Parse tree panel</strong> to highlight the corresponding text in the editor, and to see informations in the Properties panel (only for parser projects)</li></ul><h3>Command line</h3><a name="command-line-section"></a><h5>Start interactive mode</h5>

<p>Execute Ptq in interactive mode passing the option -i:</p>

<p><code>
path/to/ptq/ptq.jar -i
</code></p>

<h5>Exit interactive mode:</h5>

<p><code>
exit    # or &quot;quit&quot;
</code></p>

<h5>Create a new project in the current projects directory</h5>

<p><code>
create PROJECT_TYPE PROJECT_NAME
</code></p>

<ul><li>PROJECT_TYPE: <code>scanner</code> or <code>parser</code></li><li>PROJECT_NAME: The project name. It must contain only numbers, letters and underscores, and must begin with a letter or an underscore</li></ul>

<h5>Compile the project, generating the output scanner/parser file</h5>

<p><code>
compile PROJECT_NAME
</code></p>

<ul><li>PROJECT_NAME: A project name. The project must exists under the current Projects directory</li></ul>

<h5>Get the output in hexadecimal string format</h5>

<p><code>
hex PROJECT_NAME
</code></p>

<ul><li>PROJECT_NAME: A project name. The project must exists under the current Projects directory and must be successfully compiled first</li></ul>

<h5>Set the application language</h5>

<p><code>
set language LANGUAGE    # or &quot;set lang LANGUAGE&quot;
</code></p>

<ul><li>LANGUAGE: the application language to set, possible values are <code>it</code> (Italian), <code>en</code> (English)</li></ul>

<h5>Set the projects directory</h5>

<p><code>
set root PATH
</code></p>

<ul><li>PATH: the path to the new projects directory</li></ul>

<h5>Print informations</h5>

<p>Use the <code>echo</code> (alias: <code>print</code>) command to print informations:</p>

<ul><li><code>echo language</code> (or <code>print lang</code>): get the current application language</li><li><code>echo root</code>: get the current path of the projects directory</li><li><code>echo project-list</code>: get the list of project names in the current projects directory</li><li><code>echo charset-list</code>: get the list of available charset (the result is platform dependent)</li><li><code>echo version</code>: get the application version number</li></ul><h3>Conflicts</h3><a name="conflicts-section"></a><h4>Shift/Reduce conflicts (S/R)</h4>

<p>When a grammar allows a rule to be reduced for a certain token, but allows another rule to be shifted, there&#39;s a Shift/Reduce conflict. When that token is recognized, the parsing algorithm cannot decide between shifting a rule or reducing the other.
Here is an example:</p><pre><code class="ptqsh ptqsh-bnf">< if_statement > ::= if < condition > then < statement_list >

< if_statement > ::= if < condition > then < statement_list > else < statement_list >
</code></pre><p>The above rules describe a common if-then-else statement. This grammar is ambiguous, because when the &quot;else&quot; terminal is recognized, the parser can take two actions:</p>

<ol><li>Reduce the first rule</li><li>Shift the second rule</li></ol>

<p>Possible solutions are:</p>

<ul><li>Using the &quot;Shift on S/R conflicts&quot; option (always selected by default). When a S/R conflict occurs, the parser generator will always choose to shift. This is a very common behaviour for LR1 parser generators</li><li>Modifying the language: in the above example, you can add an &quot;end if&quot; token to terminate the if-then-else statement:</li></ul><pre><code class="ptqsh ptqsh-bnf">< if_statement > ::= if < condition > then < statement_list > end_if

< if_statement > ::= if < condition > then < statement_list > else < statement_list > end_if

</code></pre><h4>Reduce/Reduce conflicts (R/R)</h4>

<p>A Reduce/Reduce conflict occurs if there are two or more rules that apply to the same sequence of input, so the grammar allows more than one rule to be reduced for a certain token. When that token is recognized, the parsing algorithm cannot decide which of the two rules has to be reduced.</p>

<p>Usually a R/R conflict indicates a serious problem in the grammar. Usually you can resolve such kind of conflict modifying the grammar.</p>

<h4>LALR(1) conflicts</h4>

<p>Because of the way LALR(1) action-goto tables are built, some LR(1) grammars cannot be parsed using LALR(1) algorithm. If you try to generate LALR(1) tables for these grammars, you&#39;ll get a R/R conflict.</p>

<p>If this is the case, the easiest solution is to use the canonical LR1 algorithm or its reduced variant.</p><h3>Scanners</h3><a name="conflicts-section"></a><p>The scanner is the module that performs lexical analisys.
It takes in input a sequence of characters, and returns a sequence of tokens.</p>

<p>Consider the following Javascript statement:</p>

<p><code>var iNumber = 6;</code></p>

<p>The lexical analisys would return the following tokens (ignoring whitespace):</p>

<ol><li><code>var</code>: the var keyword</li><li><code>iNumber</code>: the variable identifier</li><li><code>=</code>: the assignment operator</li><li><code>6</code>: an integer literal</li><li><code>;</code>: semicolumn</li></ol>

<p>Here is a scanner for the example above, declared using Ptq scanner language:</p><pre><code class="ptqsh ptqsh-scanner">--------------------------------------------------------------------------
myScanner

  whitespace   / [:space:] + / -ignore

  var_keyword  / var /
  identifier   / [a-zA-Z_] [a-zA-Z_0-9]* /
  equals_op    / = /
  integer      / [0-9] + /
  semicolon    / ; /
</code></pre><p>Every subscanner begins with two or more Hyphen (-) characters followed by an identifier (the subscanner name), and optionally some subscanner property.</p>

<p>The subscanner definition contains the patterns to be recognized (terminals). Every terminal is declared specifying a name and a pattern, and optionally some terminal property (in the above example, the &quot;whitespace&quot; terminal has the property <strong>-ignore</strong>, that causes the token to be skipped when recognized).</p>

<h4>Switching between subscanners</h4>

<p>The  <code>-goto foo</code> property means &quot;when this pattern is matched, start using the foo scanner&quot;.
Here is an example: the following scanner recognizes the common C comment block (  /*  ...  */  )</p><pre><code class="ptqsh ptqsh-scanner">-------------------------------------------------------
main

    text            / \* | \/ | [ [:ascii:] -[ /* ]] * /
    comment_start   / \/ \* /     -goto comment_block  -ignore

-------------------------------------------------------
comment_block

    comment_body    / \* | \/ | [ [:ascii:] -[ /* ]] * /  -ignore
    comment_end     / \* \/ /     -goto main -ignore

</code></pre><p>After the <code>comment_start</code> terminal is matched, <code>comment_block</code> becomes the current subscanner.
When <code>comment_end</code> is matched, <code>main</code> becomes the current subscanner.</p>

<p>Here is a sample input text:</p>

<p><code>
if (a &gt; b) {
  /* in this comment, nesting is not supported */
  a = 0;
}
</code></p>

<p>Here&#39;s what happens:</p>

<ol><li>At input start, the first subscanner (main) is executed.</li><li>After the first <strong>/*</strong> ( <code>{main.comment_start}</code> ), comment_block becomes the current subscanner.</li><li>After the first <strong>*/</strong>  ( <code>{comment_block.comment_end}</code> ) main becomes the current subscanner.</li></ol>

<h4>Nested blocks</h4>

<p>Nested blocks can be implemented using the <code>-start</code>  and <code>-stop</code> properties to switch between subscanners.</p>

<p>Here is an example: the following scanner recognizes a nested comment block</p><pre><code class="ptqsh ptqsh-scanner">-------------------------------------------------------
main

  text          / \* | \/ | [[:ascii:]-[/*]] * /
  comment_start / \/ \* /     -start comment_block -ignore

-------------------------------------------------------
comment_block

  comment_body  / \* | \/ | [[:ascii:]-[/*]] * / -ignore
  comment_start / \/ \* /      -start comment_block -ignore
  comment_stop  / \* \/ /      -stop -ignore
</code></pre><h1>TO BE CONTINUED ...</h1>

<p>(at the moment you can visit <a href="http://alessioscalici.it/ptq/reference.html">the old ugly version</a>)</p></div></div></div></div><div id="footer-wrapper"><footer id="footer" class="container"><div class="row"><div class="3u 6u(medium) 12u$(small)"><section class="widget contact"><h3>Author</h3><a href="http://alessioscalici.it" title="Website">Alessio Scalici</a><ul class="style2"><li><a href="https://alessioscalici.github.io" title="GitHub page" class="icon fa-github"><span class="label">GitHub page</span></a></li><li><a href="https://ie.linkedin.com/in/alessioscalici" title="LinkedIn profile" class="icon fa-linkedin"><span class="label">LinkedIn</span></a></li></ul></section></div><div class="3u 6u(medium) 12u$(small)"><section class="widget links"><h3>ptq-js</h3><ul class="style2"><li>Fast</li><li>Reliable</li><li>Easy to learn</li></ul></section></div><div class="3u 6u(medium) 12u$(small)"><section class="widget links"><h3>Applications</h3><ul class="style2"><li>Language analysis</li><li>Syntax highlighting</li><li>Complex validation</li></ul></section></div><div class="3u 6u(medium) 12u$(small)"><section class="widget links"><h3>Ptq resources</h3><ul class="style2"><li><a href="http://alessioscalici.it/ptq" title="Ptq">Homepage</a></li><li><a href="http://alessioscalici.it/ptq/reference.html" title="Ptq docs">Docs</a></li><li><a href="assets/apps/ptq.jar" title="Ptq download">Download Ptq 2.0.1</a></li></ul></section></div></div><div class="row"><div class="12u"><div id="copyright"><ul class="menu"><li>&copy; Alessio Scalici. All rights reserved</li></ul></div></div></div></footer></div></div><script src="assets/js/jquery.min.js"></script><script src="assets/js/jquery.dropotron.min.js"></script><script src="assets/js/skel.min.js"></script><script src="assets/js/util.js"></script><!--[if lte IE 8]><script src="assets/js/ie/respond.min.js"></script><![endif]--><script src="assets/js/main.js"></script><script src="assets/js/prism.js"></script><script src="assets/js/jquery.qtip.min.js"></script><script src="assets/js/ptq/ptq.js"></script><script src="assets/js/ptq-sh.js"></script></body></html>