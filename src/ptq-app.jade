doctype html
html
  head
    title ptq-js by alessioscalici
    meta(charset='utf-8')
    meta(name='viewport' content='width=device-width, initial-scale=1')
    link(rel='stylesheet' href='assets/css/prism.css')
    link(rel='stylesheet' href='assets/css/jquery.qtip.min.css')
    link(rel='stylesheet' href='assets/css/main.css')
  body.homepage
    #page-wrapper
      #header-wrapper
        header.container
          #logo
            h1
              img(src='assets/images/logo.png')
              a(href='index.html') Ptq
            span the Ptq scanner / parser generator
          nav#nav
            ul
              li
                a(href='https://github.com/alessioscalici/ptq-js/')
                  span.icon.fa-github
                  span GitHub Repo
                a(href='#overview-section') Overview
                a(href='#command-line-section') Command line
                a(href='#conflicts-section') Conflicts
                a(href='#scanners-section') Scanners
                a(href='#grammars-section') Grammars
                a(href='#templates-section') Templates



      #banner-wrapper
        #banner.box.container
          .row#overview-section
            .12u.markdown



              //- ================================== OVERVIEW ================================== //

              :markdown
                ### Overview
              a(name="overview-section")
              :markdown
                Ptq is a parsing system that helps programmers to quickly develop parsers and scanners.

                It is designed to be:

                - **Cross-platform**: it's available as Windows installer and executable Jar file
                - **Cross-language**: it saves parsers and scanners in files, no language-specific code is generated
                - **Easy to learn**: it uses common regular expressions to describe parsers, and Backus-Naur Form for grammars
                - **Unicode compliant**: the scanners can handle every Unicode character
                Fast: it uses LALR(1) parsing algorithm by default




              //- ================================== FIRST STEPS ================================== //

              :markdown
                ### First steps
              a(name="first-steps-section")

              :markdown
                - Create a new project: click ```File > New project``` and insert the name of your project. Ptq will create a sample parser recognizing simple mathematical expressions
                - Compile the project clicking ```Project > Compile```
                - Open the project tree, then open the Test folder: there's a sample test file called *source.txt*. Open it (double click).

                If the last compilation was successful, when you open a test file the editor switches to the **Test perspective**.

                In the Test perspective you can:

                - Edit the text in the **editor** and save the file (File > Save all or CTRL+S)
                - Double click on the text in the editor to see token informations in the **Properties panel**
                - Click on a symbol name in the **Terminal panel** to highlight tokens in the editor
                - Click on a rule in the **Rules panel** to highlight rules in the editor

                **Only for parser projects:**

                - Click on the "play" symbol in the top-right corner of the editor to see the parse tree in the **Parse tree panel**, or an error message in the Warning panel
                - If the text isn't recognized, an error message appears in the **Warning panel**. Click on the error message in the Warning panel to highlight the row in the editor
                - Click on a node in the **Parse tree panel** to highlight the corresponding text in the editor, and to see informations in the Properties panel (only for parser projects)




              //- ================================== COMMAND LINE ================================== //

              :markdown
                ### Command line
              a(name="command-line-section")

              :markdown
                ##### Start interactive mode
                Execute Ptq in interactive mode passing the option -i:

                ```
                path/to/ptq/ptq.jar -i
                ```

                ##### Exit interactive mode:

                ```
                exit    # or "quit"
                ```


                ##### Create a new project in the current projects directory
                ```
                create PROJECT_TYPE PROJECT_NAME
                ```

                - PROJECT_TYPE: ```scanner``` or ```parser```
                - PROJECT_NAME: The project name. It must contain only numbers, letters and underscores, and must begin with a letter or an underscore


                ##### Compile the project, generating the output scanner/parser file
                ```
                compile PROJECT_NAME
                ```

                - PROJECT_NAME: A project name. The project must exists under the current Projects directory


                ##### Get the output in hexadecimal string format
                ```
                hex PROJECT_NAME
                ```

                - PROJECT_NAME: A project name. The project must exists under the current Projects directory and must be successfully compiled first

                ##### Set the application language
                ```
                set language LANGUAGE    # or "set lang LANGUAGE"
                ```

                - LANGUAGE: the application language to set, possible values are ```it``` (Italian), ```en``` (English)


                ##### Set the projects directory
                ```
                set root PATH
                ```

                - PATH: the path to the new projects directory

                ##### Print informations
                Use the ```echo``` (alias: ```print```) command to print informations:

                - ```echo language``` (or ```print lang```): get the current application language
                - ```echo root```: get the current path of the projects directory
                - ```echo project-list```: get the list of project names in the current projects directory
                - ```echo charset-list```: get the list of available charset (the result is platform dependent)
                - ```echo version```: get the application version number




              //- ================================== CONFLICTS ================================== //

              :markdown
                ### Conflicts
              a(name="conflicts-section")

              :markdown
                #### Shift/Reduce conflicts (S/R)

                When a grammar allows a rule to be reduced for a certain token, but allows another rule to be shifted, there's a Shift/Reduce conflict. When that token is recognized, the parsing algorithm cannot decide between shifting a rule or reducing the other.
                Here is an example:

              pre
                code.ptqsh.ptqsh-bnf.
                  < if_statement > ::= if < condition > then < statement_list >

                  < if_statement > ::= if < condition > then < statement_list > else < statement_list >

              :markdown
                The above rules describe a common if-then-else statement. This grammar is ambiguous, because when the "else" terminal is recognized, the parser can take two actions:

                1. Reduce the first rule
                2. Shift the second rule

                Possible solutions are:

                - Using the "Shift on S/R conflicts" option (always selected by default). When a S/R conflict occurs, the parser generator will always choose to shift. This is a very common behaviour for LR1 parser generators
                - Modifying the language: in the above example, you can add an "end if" token to terminate the if-then-else statement:

              pre
                code.ptqsh.ptqsh-bnf.
                  < if_statement > ::= if < condition > then < statement_list > end_if

                  < if_statement > ::= if < condition > then < statement_list > else < statement_list > end_if


              :markdown
                #### Reduce/Reduce conflicts (R/R)

                A Reduce/Reduce conflict occurs if there are two or more rules that apply to the same sequence of input, so the grammar allows more than one rule to be reduced for a certain token. When that token is recognized, the parsing algorithm cannot decide which of the two rules has to be reduced.

                Usually a R/R conflict indicates a serious problem in the grammar. Usually you can resolve such kind of conflict modifying the grammar.

                #### LALR(1) conflicts

                Because of the way LALR(1) action-goto tables are built, some LR(1) grammars cannot be parsed using LALR(1) algorithm. If you try to generate LALR(1) tables for these grammars, you'll get a R/R conflict.

                If this is the case, the easiest solution is to use the canonical LR1 algorithm or its reduced variant.





              //- ================================== SCANNERS ================================== //

              :markdown
                ### Scanners
              a(name="scanners-section")

              :markdown
                The scanner is the module that performs lexical analisys.
                It takes in input a sequence of characters, and returns a sequence of tokens.

                Consider the following Javascript statement:

                ```var iNumber = 6;```

                The lexical analisys would return the following tokens (ignoring whitespace):

                1. ```var```: the var keyword
                1. ```iNumber```: the variable identifier
                1. ```=```: the assignment operator
                1. ```6```: an integer literal
                1. ```;```: semicolumn

                Here is a scanner for the example above, declared using Ptq scanner language:

              pre
                code.ptqsh.ptqsh-scanner.
                  --------------------------------------------------------------------------
                  myScanner

                    whitespace   / [:space:] + / -ignore

                    var_keyword  / var /
                    identifier   / [a-zA-Z_] [a-zA-Z_0-9]* /
                    equals_op    / = /
                    integer      / [0-9] + /
                    semicolon    / ; /

              :markdown
                Every subscanner begins with two or more Hyphen (-) characters followed by an identifier (the subscanner name), and optionally some subscanner property.

                The subscanner definition contains the patterns to be recognized (terminals). Every terminal is declared specifying a name and a pattern, and optionally some terminal property (in the above example, the "whitespace" terminal has the property **-ignore**, that causes the token to be skipped when recognized).



                #### Switching between subscanners
                The  ```-goto foo``` property means "when this pattern is matched, start using the foo scanner".
                Here is an example: the following scanner recognizes the common C comment block (  /\*  ...  \*/  )

              pre
                code.ptqsh.ptqsh-scanner.
                  -------------------------------------------------------
                  main

                      text            / \* | \/ | [ [:ascii:] -[ /* ]] * /
                      comment_start   / \/ \* /     -goto comment_block  -ignore

                  -------------------------------------------------------
                  comment_block

                      comment_body    / \* | \/ | [ [:ascii:] -[ /* ]] * /  -ignore
                      comment_end     / \* \/ /     -goto main -ignore


              :markdown
                After the ```comment_start``` terminal is matched, ```comment_block``` becomes the current subscanner.
                When ```comment_end``` is matched, ```main``` becomes the current subscanner.

                Here is a sample input text:

                ```
                if (a > b) {
                  /* in this comment, nesting is not supported */
                  a = 0;
                }
                ```

                Here's what happens:

                1. At input start, the first subscanner (main) is executed.
                1. After the first **/\*** ( ```{main.comment_start}``` ), comment_block becomes the current subscanner.
                1. After the first **\*/**  ( ```{comment_block.comment_end}``` ) main becomes the current subscanner.



                #### Nested blocks
                Nested blocks can be implemented using the ```-start```  and ```-stop``` properties to switch between subscanners.

                Here is an example: the following scanner recognizes a nested comment block

              pre
                code.ptqsh.ptqsh-scanner.
                  -------------------------------------------------------
                  main

                    text          / \* | \/ | [[:ascii:]-[/*]] * /
                    comment_start / \/ \* /     -start comment_block -ignore

                  -------------------------------------------------------
                  comment_block

                    comment_body  / \* | \/ | [[:ascii:]-[/*]] * / -ignore
                    comment_start / \/ \* /      -start comment_block -ignore
                    comment_stop  / \* \/ /      -stop -ignore

              :markdown
                - The **-start** property means "when the scanner matches this pattern, start using the comment_block subscanner"
                - The **-stop** property means "when this pattern is matched, restore the previous subscanner"

                Here is a sample input text:


                ![Nested blocks example](/assets/images/nested_blocks1.png "Nested blocks example")



                1. At input start, the first subscanner (main) is executed.
                1. After the first /* ( **{ main.comment\_start }**), an instance of the comment\_block subscanner starts.
                1. After the second /* ( **{ comment\_block.comment_start }** ), another instance of the comment\_block subscanner starts.
                1. After the first */  ( **{ comment\_block.comment_stop }** ) the previous subscanner (the first instance of comment\_block) is restored.
                1. After the second */  ( **{ comment\_block.comment_stop }** ) the previous subscanner (the main subscanner) is restored.




                #### Pushback



                The **-pushback** property is always combined with **-start** or **-goto**. It means "when this pattern is matched, push back the token characters to the input text". In other words, the incoming subscanner will read those characters, even if they were already scanned.

                The following scanner recognizes a free ascii text. When a  <  is found, it ignores it (**-ignore** property) and gives the < character to the incoming subscanner (**-goto tag_sub**), that recognizes a sequence of XML-like tags.



              pre
                code.ptqsh.ptqsh-scanner.
                  -------------------------------------------------------
                  main_sub

                      free_text / [[:ascii:]-[<]] /
                      tag_start / < / -goto tag_sub -pushback -ignore

                  -------------------------------------------------------
                  tag_sub

                      tag / < [a-z] + > /
                      tag_with_ns / < [a-z]+ : [a-z]+ > /



              :markdown
                A sample input (the bold part is recognized by the **tag_sub** subscanner):

                > This is free ascii text  **<sequence><of><xml:like><tags>**

                The first ```<``` character is recognized as **{ main\_sub.tag_start }**, it is pushed back to the input stream (**-pushback** property)
                and recognized again as the first character of **{ tag_sub.tag }**




              //- ================================== CHARACTER SETS ================================== //

              :markdown
                ### Character sets
              a(name="character-sets-section")

              :markdown
                When you have to match only one character out of several characters, you need to define a character set. To define a character set, put the characters you want to match into square brackets:

                > **[AB]** _matches_ ```A``` or ```B```



                #### Metacharacters

                The usual metacharacters are normal characters inside a character set, so they don't need to be escaped. The only metacharacters in character sets are:

                - ```[``` _left square bracket_ (begin of the character set)
                - ```]``` _right square bracket_ (end of the character set)
                - ```-``` _hyphen_ (range operator)



                > **[A-D]** _matches_ ```A``` , ```B``` , ```C``` or ```D``` because the ```-``` (range operator) is not escaped

                > **[A\-D]** _matches_ ```A``` , ```-``` or ```D``` because the ```-``` is escaped

                > **[\[\]]** _matches_ ```[``` or ```]``` because the brackets characters (into the character set) are escaped



                #### Whitespaces

                In a character set, whitespaces are considered as normal characters:

                > **[ ]** _matches_ ``` ``` (whitespace)

                > **[A B]** _matches_ ```A```, ```B``` or ``` ``` (whitespace)





                #### Ranges

                An hyphen ```-``` between two characters defines a range of characters:


                > **[A-D]** _matches_ ```A``` , ```B``` , ```C``` or ```D```

                > **[0-9]** _matches_ all digits from ```0``` to ```9```

                > **[A-\u45]** _matches_ all uppercase letters from ```A``` to ```E``` (U+0045)

                > **[0\-9]** _matches_ ```0``` or ```9``` (the ```-``` is escaped)




                #### Pre-defined character sets


                ##### POSIX character classes

                > ```[:alnum:]``` _matches_ all alphanumeric characters (equiv. ```[a-zA-Z0-9]```)

                > ```[:alpha:]``` _matches_ all letters (equiv. ```[a-zA-Z]```)

                > ```[:ascii:]``` _matches_ all ASCII characters (equiv. ```[\u00-\u7F]```)




                > ```[:blank:]``` _matches_ Space and tab (equiv. ```[ \t]```)

                > ```[:cntrl:]``` _matches_ all Control characters (equiv. ```[\u00-\u1F\u7F]```)

                > ```[:digit:]``` (```\d```) _matches_ all Digits (equiv. ```[0-9]```)

                > ```[:graph:]``` _matches_ all ASCII characters (equiv. ```[\u00-\u7F]```)

                > ```[:lower:]``` _matches_ all Lowercase letters (equiv. ```[a-z]```)

                > ```[:print:]``` _matches_ all Visible characters and spaces (anything but control characters) (equiv. ```[\u20-\u7E]```)

                > ```[:punct:]``` _matches_ all Punctuation and symbols (equiv. ```[!"#$%&'()*+,\-./:;<=>?@\[\\\]^_`{|}~]```)

                > ```[:space:]``` (```\s```) _matches_ all whitespace characters, including line breaks (equiv. ```[ \t\r\n\v\f]```)

                > ```[:upper:]``` _matches_ all Uppercase letters (equiv. ```[A-Z]```)

                > ```[:word:]``` (```\w```) _matches_ all Word characters (letters, numbers and underscores) (equiv. ```[a-zA-Z0-9_]```)

                > ```[:xdigit:]``` _matches_ all Hexadecimal digits (equiv. ```[a-fA-F0-9]```)






                ##### Unicode Scripts


                You can refer to [Unicode Scripts](http://en.wikipedia.org/wiki/Script_\(Unicode\)) using their name, with the following syntax:

                **\p{**SCRIPT_NAME**}**

                For example:

                > ```\p{Latin}``` _matches_ all the characters in the "Latin" Unicode Script



                ##### Unicode Blocks


                You can refer to [Unicode Blocks](http://en.wikipedia.org/wiki/Unicode_block) using their name, with the following syntax:

                **\p{In**SCRIPT_NAME**}**

                For example:

                > ```\p{InCyrillic}``` _matches_ all the characters in the "Cyrillic" Unicode Block



                ##### Unicode Categories


                You can match characters that are part of a Unicode Category using the category name, with the following syntax:

                **\p{Is**CATEGORY_NAME**}**

                For example:

                > ```\p{InUppercase}``` _matches_ all the characters in the "Uppercase" Unicode Category






                #### Custom character classes


                If you use the same character set more than one time, you can define it once and reference it multiple times with his name:


              pre
                code.ptqsh.ptqsh-scanner.

                  // Define here your custom character sets
                  // Syntax:   NAME [ ...character set definition... ]

                  MyCharacterSet [#';]

                  -- myScanner
                      MY_TERMINAL    / {MyCharacterSet} /     // <-- matches  "#", "'" or ";"
                      MY_TERMINAL_2  / {MyCharacterSet} A  /  // <-- matches  "#A", "'A" or ";A"


              :markdown
                then, you can refer to the character set in your patterns using the syntax ```{CHARACTER_SET_NAME}```





              //- ================================== PROPERTIES ================================== //

              :markdown
                ### Properties
              a(name="properties-section")

              :markdown
                Properties are settings applicable to the global scanner, the subscanners and the terminals to
                modify the scanner behavior.


                #### Scanner properties

                ```-eos-symbol <name>``` defines a custom name for the "end of stream" symbol (default: _EOS_)

                ```-error-symbol <name>``` defines a custom name for the "error" symbol (default: _ERROR_)

                ```-begin-symbol <name>``` defines a custom name for the "begin block" symbol (default: _BEGIN_)

                ```-end-symbol <name>``` defines a custom name for the "end block" symbol (default: _END_)


                #### Sub-scanner properties

                ```-fix-priority <integer>``` The priority for every static-length terminal (e.g. keywords, operators, parentheses)

                ```-var-priority <integer>``` The priority for every variable-length terminal (e.g. identifiers, literal numbers, literal strings)


                #### Terminal properties

                ```-ignore``` Ignore this token when matched

                ```-goto <subscanner name>``` Start using another subscanner after match

                ```-start <subscanner name>``` Start using another subscanner after match. When a terminal with the **-stop** option is matched, the previous subscanner is restored

                ```-stop``` Restores the previous subscanner after match

                ```-pushback``` When **-start** or **-goto** are triggered, the current token string is pushed back into the input stream, so that the starting subscanner can read it again

                ```-priority <integer>``` When two terminals can match the same word, you can give an higher (or lower) priority to one of them

              pre
                code.ptqsh.ptqsh-scanner.
                  -- myScanner

                      WORD    / [a-z]+ /
                      FOR     / for  /


              :markdown
                Here, the word "for" can be matched by both the terminals. Setting an higher priority to FOR will resolve the conflict, matching FOR only when the word "for" is matched, and WORD in every other case:

              pre
                code.ptqsh.ptqsh-scanner.
                  -- myScanner

                      WORD    / [a-z]+ /    -priority 5
                      FOR     / for  /      -priority 3

              :markdown
                ```-indent``` In indentation-based scanners, use this property to indicate the "indentation" terminal, whose lenght determines the indentation level. This property is usually used together with the **-ignore** property. You should never put newline characters in an **-indent** terminal.

              pre
                code.ptqsh.ptqsh-scanner.
                  -- myScanner

                      INDENT     /  [ \t]+  /   -indent -ignore
                      NEWLINE    /  \n   /




              //- ================================== GRAMMARS ================================== //

              :markdown
                ### Grammars
              a(name="grammars-section")

              :markdown
                Ptq uses **BNF (Backus-Naur Form)** to define grammars, a very common notation for grammar specifications. This format is easy to understand and quick to learn.
                The BNF meta-symbols are:

                > ```::=``` **is defined as**: separates the rule's head from his handle

                > ```|``` **or**: pipe indicates alternative handles

                > ```< non_terminal_name >``` **non terminal symbol**: angle brackets surround Non-terminal symbol names

                > ```terminal_name``` **terminal symbol**: any name not surrounded by angle brackets is a Terminal symbol


                A BNF specification is a set of derivation rules, written in the following form:


                ![Rule example](/assets/images/rule.png "Rule example")

                Here is an example:


              pre
                code.ptqsh.ptqsh-bnf.
                  < expression > ::= < expression_term >
                  < expression > ::= < expression > plus < expression_term >
                  < expression > ::= < expression > minus < expression_term >

                  < expression_term > ::= integer
                  < expression_term > ::= variable_name

              :markdown
                The above grammar can be written using the pipe ```|``` choice operator:


              pre
                code.ptqsh.ptqsh-bnf.
                  < expression > ::= < expression_term >
                    |  < expression > plus < expression_term >
                    |  < expression > minus < expression_term >

                  < expression_term > ::= integer | variable_name

              :markdown
                #### Terminal and Non-terminal symbols

                In BNF specification there are two kinds of symbols: **Teminal** and **Non-terminal** symbols.

                Terminal symbols represent the text recognized and tokenized by the scanner. In a parse tree, terminals are always leaves, and each of them represents a token. They are referenced in the grammar specification using their name (the identifier used in the scanner specification).

                Terminal symbols have to be defined in the scanner specification as non-ignored terminals (they must be defined at least in one subscanner without the -ignore property), using their identifier.

                Non-terminal symbols represent the rules used to derive the input text. In a parse tree, they are represented by non-terminal nodes. They are referenced using an identifier surrounded by angle brackets.

                Non-terminal symbols have to be defined as head symbol for at least one rule. They can be referenced using their identifier surrounded by angle brackets ```<>```.




              //- ================================== TEMPLATES ================================== //

              :markdown
                ### Templates
              a(name="templates-section")

              :markdown
                Every symbol and every rule in the scanner/parser are identified by an index (32 bit integer).

                Usually, a developer has to write a set of constants/enumeration to easily identify specific rules and symbols in the code, but this can be a really tedious task because:

                1. A scanner/parser can have dozens (or hundreds!) of rules/symbols
                1. Indexes may vary if a scanner/parser is modified
                1. It's boring

                To makes things easier, PTQ provides a template processing tool that allows automatic generation of this kind of code.
                A template is a normal text file, coden in the targeted language, with some pre-processing tags. For example, the following template:




              pre
                code.lang-template.
                  public enum #project name#Symbols
                  {
                      #foreach symbol#
                      S_#name# = #index# %%,%%
                      #end symbol#
                  }


              :markdown
                Will result in a Java enum like the following:

              pre
                code.lang-template.
                  public enum MyProjectSymbols
                  { 
                      S__EOS_ = 0,
                      S__ERROR_ = 1,
                      S_MY_FIRST_SYMBOL = 2,
                      S_MY_SECOND_SYMBOL = 3,
                      S_MY_THIRD_SYMBOL = 4
                  }


              :markdown
                #### Tag list

                ##### Global

                ```#project name#``` The project name

                ```#terminal count#``` The number of terminal symbols

                ```#start symbol name#``` The grammar start symbol name

                ```#start symbol index#``` The grammar start symbol index

                ```#symbol count#``` The total number of symbols ( terminal + non-terminal )

                ```#rule count#``` The number of  rules in the grammar


                ##### List separator

                ```%%``` In every list you can surround a list separator between **%%** (e.g.  ```%%,%%```). The separator will be omitted after the last occurrence in the list.


                ##### Terminal list

                ```#for each terminal#``` Starts the terminal symbol list. The code between this tag and **#end terminal#** will be repeated for each terminal symbol

                ```#name#``` The terminal name (identifier)

                ```#index#``` The terminal index

                ```#display name#``` The terminal display name

                ```#end terminal#``` Terminates the terminal symbol list


                ##### Symbol list

                ```#for each symbol#``` Starts the symbol list. The code between this tag and **#end symbol#** will be repeated for each symbol (terminal + non-terminal)

                ```#name#``` The symbol name (identifier)

                ```#index#``` The symbol index

                ```#end symbol#``` Terminates the symbol list



                ##### Rule list

                ```#for each rule#``` Starts the rule list. The code between this tag and **#end rule#** will be repeated for each grammar rule

                ```#rule#``` The grammar rule in BNF format (e.g.  ```<expr> ::= LPAR <expr> RPAR``` )

                ```#rule index#``` The rule index

                ```#rule identifier#``` A unique rule identifier, built using symbols name (e.g. ```expr_LPAR_expr_RPAR```), can be used to have an index-independent identifier for the rule

                ```#rule md5#``` The MD5 digest string of the rule, can be used to have an index-independent identifier for the rule

                ```#head name#``` The name of the head symbol (LHS)

                ```#head index#``` The index of the head symbol (LHS)

                ```#element count#``` The number of symbols in the rule's tail (RHS)

                ```#for each element#``` Starts the rule tail list. The code between this tag and **#end element#** will be repeated for each symbol in the rule tail (RHS)

                ```#name#``` The RHS symbol name

                ```#index#``` The RHS symbol index

                ```#end element#``` Terminates the rule tail list

                ```#end rule#``` Terminates the rule list



                ##### Non-terminal list

                ```#for each nonterminal#``` Starts the non-terminal symbol list. The code between this tag and **#end nonterminal#** will be repeated for each non-terminal symbol

                ```#name#``` The non-terminal symbol name (identifier)

                ```#index#``` The non-terminal symbol index

                ```#for each rule#``` Starts the rule list. The code between this tag and **#end rule#** will be repeated for each grammar rule with the current non-terminal symbol as his head (LHS)

                _... see rule tags ..._

                ```#end rule#``` Terminates the rule list

                ```#end nonterminal#``` Terminates the non-terminal symbol list



      #footer-wrapper
        footer#footer.container
          .row
            div(class='3u 6u(medium) 12u$(small)')
              section.widget.contact
                h3 Author
                a(href='http://alessioscalici.it' title='Website') Alessio Scalici
                ul.style2
                  li
                    a(href='https://alessioscalici.github.io' title='GitHub page').icon.fa-github
                      span.label GitHub page
                  li
                    a(href='https://ie.linkedin.com/in/alessioscalici' title='LinkedIn profile').icon.fa-linkedin
                      span.label LinkedIn

            div(class='3u 6u(medium) 12u$(small)')
              section.widget.links
                h3 ptq-js
                ul.style2
                  li Fast
                  li Reliable
                  li Easy to learn
            div(class='3u 6u(medium) 12u$(small)')
              section.widget.links
                h3 Applications
                ul.style2
                  li Language analysis
                  li Syntax highlighting
                  li Complex validation

            div(class='3u 6u(medium) 12u$(small)')
              section.widget.links
                h3 Ptq resources
                ul.style2
                  li
                    a(href='http://alessioscalici.it/ptq' title='Ptq') Homepage
                  li
                    a(href='http://alessioscalici.it/ptq/reference.html' title='Ptq docs') Docs
                  li
                    a(href='assets/apps/ptq.jar' title='Ptq download') Download Ptq 2.0.1


          .row
            .12u
              #copyright
                ul.menu
                  li &copy; Alessio Scalici. All rights reserved

    script(src='assets/js/jquery.min.js')
    script(src='assets/js/jquery.dropotron.min.js')
    script(src='assets/js/skel.min.js')
    script(src='assets/js/util.js')
    | <!--[if lte IE 8]><script src="assets/js/ie/respond.min.js"></script><![endif]-->
    script(src='assets/js/main.js')

    script(src='assets/js/prism.js')
    script(src='assets/js/jquery.qtip.min.js')
    script(src='assets/js/ptq/ptq.js')
    script(src='assets/js/ptq-sh.js')
